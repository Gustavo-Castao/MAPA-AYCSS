<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa Interactivo Arte y Ciencias Sociales - VERSI√ìN ESTABLE</title>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        /* [Mant√©n todos los estilos CSS iguales hasta el final] */
        /* ... Todos los estilos anteriores se mantienen igual ... */
    </style>
</head>
<body>
    <!-- [Mant√©n toda la estructura HTML igual hasta el final] -->
    <!-- ... Todo el HTML anterior se mantiene igual ... -->

    <script>
        // ============================================
        // ARQUITECTURA REVISADA - VERSI√ìN ESTABLE
        // ============================================
        
        // Variables globales con inicializaci√≥n expl√≠cita
        let nodes = [];
        let connections = [];
        let connectionMode = false;
        let disconnectMode = false;
        let sourceNodeId = null;
        let nodeCounter = 0;
        let currentImage = null;
        let editingNodeId = null;
        let selectedNodeId = null;
        let selectedConnection = null;
        let zoomLevel = 1;
        let translateX = 0, translateY = 0;
        
        // Variables de personalizaci√≥n de nodo
        let selectedNodeColor = '#ffffff';
        let selectedTextColor = 'black';
        let selectedFontSize = 'small';
        let selectedFontFamily = 'Roboto';
        let selectedBorder = 'solid';
        
        // Variables para configuraci√≥n de fondo
        let backgroundImage = null;
        
        // Historial para deshacer acciones
        let history = [];
        let historyIndex = -1;
        
        // Variables para el selector de color personalizado
        let currentColorPickerType = null;
        let customColor = { r: 255, g: 255, b: 255 };
        
        // Variable para copiar/pegar
        let copiedNode = null;
        
        // Sistema de cache para referencias de elementos DOM
        const domCache = {
            nodes: new Map(),
            connections: new Map()
        };

        // Elementos DOM
        const workspace = document.getElementById('workspace');
        const a4Container = document.getElementById('a4Container');
        const connectionModeDiv = document.getElementById('connectionMode');
        const disconnectModeDiv = document.getElementById('disconnectMode');

        // ============================================
        // FUNCIONES DE GESTI√ìN DE NODOS - REVISADAS
        // ============================================

        // Sistema de selecci√≥n robusto
        class NodeSelectionManager {
            constructor() {
                this.selectedNodeId = null;
                this.selectedConnection = null;
                this.lastSelected = null;
            }
            
            selectNode(nodeId) {
                // Deseleccionar nodo anterior
                if (this.selectedNodeId && this.selectedNodeId !== nodeId) {
                    this.deselectNode(this.selectedNodeId);
                }
                
                // Deseleccionar conexi√≥n si hab√≠a una seleccionada
                if (this.selectedConnection) {
                    this.deselectConnection(this.selectedConnection);
                    this.selectedConnection = null;
                }
                
                // Seleccionar nuevo nodo
                this.selectedNodeId = nodeId;
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) {
                    nodeElement.classList.add('selected');
                }
                
                this.lastSelected = { type: 'node', id: nodeId };
                return this.selectedNodeId;
            }
            
            deselectNode(nodeId) {
                if (!nodeId) return;
                
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) {
                    nodeElement.classList.remove('selected');
                }
                
                if (this.selectedNodeId === nodeId) {
                    this.selectedNodeId = null;
                }
            }
            
            selectConnection(conn) {
                // Deseleccionar nodo si hab√≠a uno seleccionado
                if (this.selectedNodeId) {
                    this.deselectNode(this.selectedNodeId);
                    this.selectedNodeId = null;
                }
                
                // Deseleccionar conexi√≥n anterior
                if (this.selectedConnection) {
                    this.deselectConnection(this.selectedConnection);
                }
                
                // Seleccionar nueva conexi√≥n
                this.selectedConnection = conn;
                const line = document.getElementById('conn-' + conn.from + '-' + conn.to);
                const arrow = document.getElementById('arrow-' + conn.from + '-' + conn.to);
                
                if (line) line.classList.add('selected');
                if (arrow) arrow.classList.add('selected');
                
                this.lastSelected = { type: 'connection', data: conn };
                return this.selectedConnection;
            }
            
            deselectConnection(conn) {
                if (!conn) return;
                
                const line = document.getElementById('conn-' + conn.from + '-' + conn.to);
                const arrow = document.getElementById('arrow-' + conn.from + '-' + conn.to);
                
                if (line) line.classList.remove('selected');
                if (arrow) arrow.classList.remove('selected');
                
                if (this.selectedConnection === conn) {
                    this.selectedConnection = null;
                }
            }
            
            clearSelection() {
                if (this.selectedNodeId) {
                    this.deselectNode(this.selectedNodeId);
                }
                if (this.selectedConnection) {
                    this.deselectConnection(this.selectedConnection);
                }
                this.selectedNodeId = null;
                this.selectedConnection = null;
                this.lastSelected = null;
            }
            
            getSelectedNode() {
                if (!this.selectedNodeId) return null;
                return nodes.find(n => n.id === this.selectedNodeId);
            }
            
            getSelectedNodeIndex() {
                if (!this.selectedNodeId) return -1;
                return nodes.findIndex(n => n.id === this.selectedNodeId);
            }
        }

        // Instanciar el gestor de selecci√≥n
        const selectionManager = new NodeSelectionManager();

        // ============================================
        // FUNCIONES PRINCIPALES REVISADAS
        // ============================================

        // Guardar estado actual en el historial
        function saveState() {
            // Eliminar estados futuros si estamos en medio del historial
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            // Guardar estado actual
            history.push({
                nodes: JSON.parse(JSON.stringify(nodes)),
                connections: JSON.parse(JSON.stringify(connections)),
                selectedNodeId: selectionManager.selectedNodeId,
                selectedConnection: selectionManager.selectedConnection
            });
            
            historyIndex = history.length - 1;
            
            // Limitar el historial a 50 estados
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
            
            updateUndoCount();
        }

        // Deshacer √∫ltima acci√≥n
        function undoAction() {
            if (historyIndex > 0) {
                historyIndex--;
                const state = history[historyIndex];
                
                // Restaurar estado
                nodes = JSON.parse(JSON.stringify(state.nodes));
                connections = JSON.parse(JSON.stringify(state.connections));
                
                // Restaurar selecci√≥n
                selectionManager.clearSelection();
                if (state.selectedNodeId) {
                    selectionManager.selectNode(state.selectedNodeId);
                } else if (state.selectedConnection) {
                    selectionManager.selectConnection(state.selectedConnection);
                }
                
                // Re-renderizar
                renderAll();
                updateCounters();
                updateUndoCount();
            } else {
                alert("No hay m√°s acciones para deshacer");
            }
        }

        // Modal functions
        function showNodeModal() {
            document.getElementById('nodeModal').style.display = 'block';
            document.getElementById('nodeModalTitle').textContent = 'CREAR NUEVO NODO';
            clearNodeForm();
            editingNodeId = null;
        }

        function closeNodeModal() {
            document.getElementById('nodeModal').style.display = 'none';
            editingNodeId = null;
        }

        // FUNCI√ìN CORREGIDA: Editar nodo seleccionado
        function editSelectedNode() {
            const selectedNode = selectionManager.getSelectedNode();
            if (!selectedNode) {
                alert('Por favor selecciona un nodo primero haciendo clic en √©l');
                return;
            }

            editingNodeId = selectedNode.id;
            document.getElementById('nodeModalTitle').textContent = 'EDITAR NODO';
            
            // Llenar formulario con datos existentes del nodo
            document.getElementById('nodeTitle').value = selectedNode.title;
            document.getElementById('nodeSubtitle').value = selectedNode.subtitle || '';
            document.getElementById('nodeAuthor').value = selectedNode.author || '';
            document.getElementById('nodeDescription').value = selectedNode.description || '';
            
            // Configurar personalizaci√≥n
            selectedNodeColor = selectedNode.color || '#ffffff';
            selectedTextColor = selectedNode.textColor || 'black';
            selectedFontSize = selectedNode.fontSize || 'small';
            selectedFontFamily = selectedNode.fontFamily || 'Roboto';
            selectedBorder = selectedNode.border || 'solid';
            
            updateCustomizationSelectors();
            
            // Manejar imagen
            const preview = document.getElementById('imagePreview');
            if (selectedNode.image) {
                preview.src = selectedNode.image;
                preview.style.display = 'block';
                currentImage = selectedNode.image;
            } else {
                preview.style.display = 'none';
                currentImage = null;
            }
            
            document.getElementById('nodeModal').style.display = 'block';
        }

        // FUNCI√ìN CORREGIDA: Eliminar nodo seleccionado
        function deleteSelectedNode() {
            const selectedNode = selectionManager.getSelectedNode();
            if (!selectedNode) {
                alert('Por favor selecciona un nodo primero haciendo clic en √©l');
                return;
            }

            if (!confirm('¬øEst√°s seguro de que quieres eliminar este nodo?')) return;

            // Guardar estado actual antes de eliminar
            saveState();

            // Eliminar conexiones relacionadas
            connections = connections.filter(conn => 
                conn.from !== selectedNode.id && conn.to !== selectedNode.id
            );

            // Eliminar nodo
            const nodeIndex = nodes.findIndex(n => n.id === selectedNode.id);
            if (nodeIndex !== -1) {
                nodes.splice(nodeIndex, 1);
                selectionManager.clearSelection();
                
                // Re-renderizar
                renderAll();
                updateCounters();
            }
        }

        // Mostrar modal de descripci√≥n - FUNCI√ìN REVISADA
        function showDescriptionModal(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) {
                console.error('Nodo no encontrado:', nodeId);
                return;
            }

            document.getElementById('modalTitle').textContent = node.title;
            document.getElementById('modalSubtitle').textContent = node.subtitle || 'Sin subt√≠tulo';
            document.getElementById('modalAuthor').textContent = node.author ? `Autor: ${node.author}` : 'Autor no especificado';
            document.getElementById('modalDescription').textContent = node.description || 'Sin descripci√≥n disponible.';
            
            const modalImage = document.getElementById('modalImage');
            if (node.image) {
                modalImage.src = node.image;
                modalImage.style.display = 'block';
            } else {
                modalImage.style.display = 'none';
            }
            
            document.getElementById('descriptionModal').style.display = 'block';
        }

        // Guardar nodo (crear o editar) - FUNCI√ìN REVISADA
        function saveNode() {
            const title = document.getElementById('nodeTitle').value.trim();
            const subtitle = document.getElementById('nodeSubtitle').value.trim();
            const author = document.getElementById('nodeAuthor').value.trim();
            const description = document.getElementById('nodeDescription').value.trim();

            if (!title) {
                alert('Por favor ingresa un t√≠tulo');
                return;
            }

            // Guardar estado actual antes de realizar cambios
            saveState();

            if (editingNodeId) {
                // Editar nodo existente
                const nodeIndex = nodes.findIndex(n => n.id === editingNodeId);
                if (nodeIndex !== -1) {
                    nodes[nodeIndex].title = title;
                    nodes[nodeIndex].subtitle = subtitle;
                    nodes[nodeIndex].author = author;
                    nodes[nodeIndex].description = description;
                    nodes[nodeIndex].image = currentImage;
                    nodes[nodeIndex].color = selectedNodeColor;
                    nodes[nodeIndex].textColor = selectedTextColor;
                    nodes[nodeIndex].fontSize = selectedFontSize;
                    nodes[nodeIndex].fontFamily = selectedFontFamily;
                    nodes[nodeIndex].border = selectedBorder;
                    
                    // Re-seleccionar el nodo editado
                    selectionManager.selectNode(editingNodeId);
                    
                    // Re-renderizar
                    renderAll();
                }
            } else {
                // Crear nuevo nodo
                nodeCounter++;
                const nodeId = 'node-' + nodeCounter;

                // Posici√≥n aleatoria en el workspace A4
                const x = Math.random() * (a4Container.offsetWidth - 100) + 20;
                const y = Math.random() * (a4Container.offsetHeight - 60) + 20;

                const node = {
                    id: nodeId,
                    title: title,
                    subtitle: subtitle,
                    author: author,
                    description: description,
                    image: currentImage,
                    type: 'main',
                    x: x,
                    y: y,
                    color: selectedNodeColor,
                    textColor: selectedTextColor,
                    fontSize: selectedFontSize,
                    fontFamily: selectedFontFamily,
                    border: selectedBorder
                };

                nodes.push(node);
                renderNode(node);
                updateCounters();
                
                // Seleccionar el nuevo nodo
                selectionManager.selectNode(nodeId);
            }

            closeNodeModal();
        }

        // ============================================
        // SISTEMA DE RENDERIZADO REVISADO
        // ============================================

        // Renderizar nodo en el workspace - FUNCI√ìN COMPLETAMENTE REVISADA
        function renderNode(node) {
            // Eliminar nodo existente si ya est√° renderizado
            const existingNode = document.getElementById(node.id);
            if (existingNode) {
                existingNode.remove();
            }
            
            const nodeElement = document.createElement('div');
            nodeElement.className = `node node-main ${node.fontSize || 'small'}`;
            nodeElement.id = node.id;
            nodeElement.dataset.nodeId = node.id; // Dataset para referencia segura
            nodeElement.style.left = node.x + 'px';
            nodeElement.style.top = node.y + 'px';
            nodeElement.style.fontFamily = node.fontFamily || 'Roboto';
            
            // Aplicar color de fondo
            if (node.color === 'transparent') {
                nodeElement.style.background = 'transparent';
            } else {
                nodeElement.style.background = node.color || '#ffffff';
            }
            
            // Aplicar borde
            if (node.border === 'none') {
                nodeElement.style.border = 'none';
            } else {
                nodeElement.style.border = '1.3px solid #8e44ad';
            }
            
            nodeElement.style.color = node.textColor || 'black';
            
            nodeElement.innerHTML = `
                <div class="node-title">${node.title}</div>
                ${node.subtitle ? `<div class="node-subtitle">${node.subtitle}</div>` : ''}
            `;

            // Hacer arrastrable
            makeDraggable(nodeElement, node);

            // EVENTOS REVISADOS - Sistema de selecci√≥n robusto
            nodeElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevenir propagaci√≥n
                
                if (e.target.classList.contains('node-btn')) return;
                
                // Si estamos en modo desconexi√≥n, no seleccionar nodos
                if (disconnectMode) return;
                
                // Seleccionar nodo
                selectionManager.selectNode(node.id);
                
                if (connectionMode && sourceNodeId && sourceNodeId !== node.id) {
                    createConnection(sourceNodeId, node.id);
                    setConnectionMode(false);
                } else if (connectionMode && !sourceNodeId) {
                    sourceNodeId = node.id;
                    connectionModeDiv.textContent = 'üîó Modo Conexi√≥n: Selecciona el nodo destino';
                }
            });

            // Evento doble click para mostrar descripci√≥n
            nodeElement.addEventListener('dblclick', function(e) {
                e.stopPropagation();
                
                if (e.target.classList.contains('node-btn')) return;
                
                if (!connectionMode && !disconnectMode) {
                    showDescriptionModal(node.id);
                }
            });

            workspace.appendChild(nodeElement);
            
            // Actualizar cache
            domCache.nodes.set(node.id, nodeElement);
        }

        // Hacer nodo arrastrable - FUNCI√ìN REVISADA
        function makeDraggable(element, node) {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            // Eventos para mouse
            element.addEventListener('mousedown', startDrag);
            
            // Eventos para pantallas t√°ctiles
            element.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                startDragTouch(touch);
            });

            function startDrag(e) {
                if (e.target.classList.contains('node-btn')) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                // Seleccionar nodo al empezar a arrastrar
                selectionManager.selectNode(node.id);
                
                isDragging = true;
                element.classList.add('dragging');
                
                startX = e.clientX;
                startY = e.clientY;
                initialX = element.offsetLeft;
                initialY = element.offsetTop;
                
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', stopDrag);
            }
            
            function startDragTouch(touch) {
                if (touch.target.classList.contains('node-btn')) return;
                
                // Seleccionar nodo al empezar a arrastrar
                selectionManager.selectNode(node.id);
                
                isDragging = true;
                element.classList.add('dragging');
                
                startX = touch.clientX;
                startY = touch.clientY;
                initialX = element.offsetLeft;
                initialY = element.offsetTop;
                
                document.addEventListener('touchmove', onDragTouch);
                document.addEventListener('touchend', stopDrag);
            }

            function onDrag(e) {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                updateNodePosition(dx, dy);
            }
            
            function onDragTouch(e) {
                if (!isDragging) return;
                
                const touch = e.touches[0];
                const dx = touch.clientX - startX;
                const dy = touch.clientY - startY;
                
                updateNodePosition(dx, dy);
            }
            
            function updateNodePosition(dx, dy) {
                let newX = initialX + dx;
                let newY = initialY + dy;

                // Mantener dentro de los l√≠mites del A4
                newX = Math.max(6.5, Math.min(newX, a4Container.offsetWidth - element.offsetWidth - 6.5));
                newY = Math.max(6.5, Math.min(newY, a4Container.offsetHeight - element.offsetHeight - 6.5));

                element.style.left = newX + 'px';
                element.style.top = newY + 'px';
                
                node.x = newX;
                node.y = newY;

                updateConnections();
            }

            function stopDrag() {
                isDragging = false;
                element.classList.remove('dragging');
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchmove', onDragTouch);
                document.removeEventListener('touchend', stopDrag);
                
                // Guardar estado despu√©s de mover un nodo
                saveState();
            }
        }

        // ============================================
        // SISTEMA DE CONEXIONES REVISADO
        // ============================================

        // Iniciar modo conexi√≥n
        function startConnection() {
            if (nodes.length < 2) {
                alert('Necesitas al menos 2 nodos para crear conexiones');
                return;
            }
            setConnectionMode(true);
            setDisconnectMode(false);
            sourceNodeId = null;
            connectionModeDiv.textContent = 'üîó Modo Conexi√≥n: Selecciona el primer nodo';
        }

        // Activar/desactivar modo conexi√≥n
        function setConnectionMode(active) {
            connectionMode = active;
            if (active) {
                connectionModeDiv.style.display = 'block';
                connectionModeDiv.textContent = 'üîó Modo Conexi√≥n: Selecciona el primer nodo';
            } else {
                connectionModeDiv.style.display = 'none';
                sourceNodeId = null;
            }
        }

        // Iniciar modo desconexi√≥n
        function startDisconnect() {
            if (connections.length === 0) {
                alert('No hay conexiones para eliminar');
                return;
            }
            setDisconnectMode(true);
            setConnectionMode(false);
            disconnectModeDiv.textContent = '‚ùå Modo Desconexi√≥n: Selecciona una conexi√≥n para eliminar';
        }

        // Activar/desactivar modo desconexi√≥n - FUNCI√ìN REVISADA
        function setDisconnectMode(active) {
            disconnectMode = active;
            if (active) {
                disconnectModeDiv.style.display = 'block';
                disconnectModeDiv.textContent = '‚ùå Modo Desconexi√≥n: Selecciona una conexi√≥n para eliminar';
                
                // Deseleccionar cualquier nodo seleccionado
                selectionManager.clearSelection();
                
                // Hacer las conexiones clickeables
                connections.forEach(conn => {
                    const line = document.getElementById('conn-' + conn.from + '-' + conn.to);
                    const arrow = document.getElementById('arrow-' + conn.from + '-' + conn.to);
                    
                    if (line && arrow) {
                        line.style.pointerEvents = 'auto';
                        arrow.style.pointerEvents = 'auto';
                        
                        // Remover listeners anteriores para evitar duplicados
                        line.removeEventListener('click', handleConnectionClick);
                        arrow.removeEventListener('click', handleConnectionClick);
                        
                        // Agregar nuevos listeners
                        line.addEventListener('click', () => handleConnectionClick(conn));
                        arrow.addEventListener('click', () => handleConnectionClick(conn));
                    }
                });
            } else {
                disconnectModeDiv.style.display = 'none';
                
                // Restaurar conexiones a no clickeables
                connections.forEach(conn => {
                    const line = document.getElementById('conn-' + conn.from + '-' + conn.to);
                    const arrow = document.getElementById('arrow-' + conn.from + '-' + conn.to);
                    
                    if (line && arrow) {
                        line.style.pointerEvents = 'none';
                        arrow.style.pointerEvents = 'none';
                        
                        // Remover listeners
                        line.removeEventListener('click', handleConnectionClick);
                        arrow.removeEventListener('click', handleConnectionClick);
                    }
                });
            }
        }

        // Manejador de clic en conexiones
        function handleConnectionClick(conn) {
            if (!disconnectMode) return;
            
            if (confirm('¬øEst√°s seguro de que quieres eliminar esta conexi√≥n?')) {
                // Guardar estado antes de eliminar
                saveState();
                
                // Eliminar conexi√≥n
                connections = connections.filter(c => 
                    !(c.from === conn.from && c.to === conn.to)
                );
                
                // Re-renderizar
                renderAll();
                updateCounters();
                
                // Salir del modo desconexi√≥n si no hay m√°s conexiones
                if (connections.length === 0) {
                    setDisconnectMode(false);
                }
            }
        }

        // Crear conexi√≥n entre nodos
        function createConnection(fromId, toId) {
            // Evitar conexiones duplicadas
            const existingConnection = connections.find(conn => 
                (conn.from === fromId && conn.to === toId) || 
                (conn.from === toId && conn.to === fromId)
            );

            if (existingConnection) {
                alert('Estos nodos ya est√°n conectados');
                return;
            }

            if (fromId === toId) {
                alert('No puedes conectar un nodo consigo mismo');
                return;
            }

            // Guardar estado antes de crear conexi√≥n
            saveState();

            connections.push({ from: fromId, to: toId });
            renderConnection(fromId, toId);
            updateCounters();
        }

        // Renderizar conexi√≥n
        function renderConnection(fromId, toId) {
            const connectionId = `conn-${fromId}-${toId}`;
            const arrowId = `arrow-${fromId}-${toId}`;
            
            // Eliminar conexi√≥n existente si ya est√° renderizada
            const existingLine = document.getElementById(connectionId);
            const existingArrow = document.getElementById(arrowId);
            if (existingLine) existingLine.remove();
            if (existingArrow) existingArrow.remove();

            // Crear l√≠nea
            const line = document.createElement('div');
            line.className = 'connection';
            line.id = connectionId;
            line.style.pointerEvents = disconnectMode ? 'auto' : 'none';

            // Crear flecha
            const arrow = document.createElement('div');
            arrow.className = 'connection-arrow';
            arrow.id = arrowId;
            arrow.style.pointerEvents = disconnectMode ? 'auto' : 'none';

            workspace.appendChild(line);
            workspace.appendChild(arrow);

            updateConnection(fromId, toId);
            
            // Agregar listeners si estamos en modo desconexi√≥n
            if (disconnectMode) {
                const conn = connections.find(c => c.from === fromId && c.to === toId);
                if (conn) {
                    line.addEventListener('click', () => handleConnectionClick(conn));
                    arrow.addEventListener('click', () => handleConnectionClick(conn));
                }
            }
        }

        // Actualizar posici√≥n de conexi√≥n
        function updateConnection(fromId, toId) {
            const fromNode = nodes.find(n => n.id === fromId);
            const toNode = nodes.find(n => n.id === toId);
            const line = document.getElementById('conn-' + fromId + '-' + toId);
            const arrow = document.getElementById('arrow-' + fromId + '-' + toId);

            if (!fromNode || !toNode || !line || !arrow) return;

            const fromElement = document.getElementById(fromId);
            const toElement = document.getElementById(toId);

            if (!fromElement || !toElement) return;

            const fromX = fromNode.x + fromElement.offsetWidth / 2;
            const fromY = fromNode.y + fromElement.offsetHeight / 2;
            const toX = toNode.x + toElement.offsetWidth / 2;
            const toY = toNode.y + toElement.offsetHeight / 2;

            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            line.style.width = length + 'px';
            line.style.left = fromX + 'px';
            line.style.top = fromY + 'px';
            line.style.transform = 'rotate(' + angle + 'deg)';

            arrow.style.left = toX + 'px';
            arrow.style.top = toY + 'px';
            arrow.style.transform = 'rotate(' + angle + 'deg)';
        }

        // Actualizar todas las conexiones
        function updateConnections() {
            connections.forEach(conn => {
                updateConnection(conn.from, conn.to);
            });
        }

        // ============================================
        // FUNCIONES AUXILIARES
        // ============================================

        // Actualizar contadores
        function updateCounters() {
            document.getElementById('nodesCount').textContent = nodes.length;
            document.getElementById('connectionsCount').textContent = connections.length;
        }

        // Actualizar contador de acciones deshacer
        function updateUndoCount() {
            document.getElementById('undoCount').textContent = historyIndex;
        }

        // Limpiar todo
        function clearAll() {
            if (!confirm('¬øEst√°s seguro de que quieres eliminar todo?')) return;
            
            // Guardar estado antes de limpiar
            saveState();
            
            nodes = [];
            connections = [];
            selectionManager.clearSelection();
            renderAll();
            updateCounters();
        }

        // Renderizar todo
        function renderAll() {
            workspace.innerHTML = '';
            domCache.nodes.clear();
            domCache.connections.clear();
            
            // Renderizar nodos primero
            nodes.forEach(node => renderNode(node));
            
            // Renderizar conexiones despu√©s
            connections.forEach(conn => renderConnection(conn.from, conn.to));
            
            updateWorkspaceTransform();
            
            // Reactivar modo si es necesario
            if (disconnectMode) {
                setDisconnectMode(true);
            }
        }

        // Funci√≥n para alternar men√∫ m√≥vil
        function toggleMobileMenu() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('active');
        }

        // Actualizar t√≠tulo del mapa
        function updateMapTitle(title) {
            document.title = title + " - Mapa Interactivo";
        }

        // ============================================
        // INICIALIZACI√ìN
        // ============================================

        // Inicializar
        document.addEventListener('DOMContentLoaded', function() {
            renderAll();
            updateCounters();
            saveState(); // Guardar estado inicial
            
            // Agregar nodos de ejemplo
            setTimeout(() => {
                const node1 = {
                    id: 'node-1',
                    title: 'Arte y Ciencias Sociales',
                    subtitle: 'Intersecciones disciplinares',
                    author: 'Varios autores',
                    description: 'Este mapa explora las conexiones entre el arte y las ciencias sociales, examinando c√≥mo se influyen mutuamente.',
                    image: null,
                    type: 'main',
                    x: 100,
                    y: 100,
                    color: '#ffffff',
                    textColor: 'black',
                    fontSize: 'small',
                    fontFamily: 'Roboto',
                    border: 'solid'
                };

                const node2 = {
                    id: 'node-2',
                    title: 'Antropolog√≠a Visual',
                    subtitle: 'Estudio cultural de las im√°genes',
                    author: 'Margaret Mead',
                    description: 'La antropolog√≠a visual estudia c√≥mo las sociedades humanas producen, interpretan y utilizan las im√°genes visuales.',
                    image: null,
                    type: 'main',
                    x: 300,
                    y: 200,
                    color: '#ffffff',
                    textColor: 'black',
                    fontSize: 'small',
                    fontFamily: 'Roboto',
                    border: 'solid'
                };

                nodes.push(node1, node2);
                renderAll();
                updateCounters();
                saveState(); // Guardar estado con nodos de ejemplo
                
                // Crear una conexi√≥n de ejemplo
                setTimeout(() => {
                    connections.push({ from: 'node-1', to: 'node-2' });
                    renderAll();
                    updateCounters();
                    saveState();
                }, 100);
            }, 100);
        });

        // ============================================
        // FUNCIONES QUE SE MANTIENEN IGUAL
        // ============================================
        
        // [Aqu√≠ mant√©n todas las dem√°s funciones que no han sido modificadas:
        // previewImage, updateCustomColor, exportToPNG, clearNodeForm, 
        // updateCustomizationSelectors, getFontSizeLabel, getFontFamilyLabel,
        // selectTextColor, selectFontSize, selectFontFamily, showSaveModal,
        // closeSaveModal, downloadHTML, generateExportCode, openPreviewModal,
        // closePreviewModal, updatePreviewContent, printPreview, zoomIn,
        // zoomOut, resetZoom, updateWorkspaceTransform, showBackgroundModal,
        // closeBackgroundModal, showColorPickerModal, closeColorPickerModal,
        // updateCustomColorFromInput, applyCustomColor, previewBackgroundImage,
        // applyBackgroundImage, removeBackgroundImage, applyMapSize,
        // changeMapBackground, applyBackground, copySelectedNode, pasteNode,
        // loadFromHTML, y todas las funciones de cierre de modales]
        
        // IMPORTANTE: Mant√©n el c√≥digo de estas funciones exactamente como estaba
        // ya que no han sido modificadas en esta revisi√≥n

    </script>
</body>
</html>
